/*******************************************************************************
 * Copyright (c) 2009 Siemens AG
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Kai Toedter - initial API and implementation
 *******************************************************************************/

package com.siemens.ct.osgi.a4ds;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementScanner6;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;

import org.jdom.Comment;
import org.jdom.Document;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;

@SupportedAnnotationTypes(value = { "com.siemens.ct.osgi.a4ds.*" })
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class Processor extends AbstractProcessor {

	private final Scanner scanner = new Scanner();
	private org.jdom.Element component = null;
	private Hashtable<String, org.jdom.Element> references = null;
	private String outputDir = null;
	private boolean errorsFound;

	public String getOutputDir() {
		return outputDir;
	}

	public void setOutputDir(String outputDir) {
		this.outputDir = outputDir;
	}

	@Override
	public boolean process(Set<? extends TypeElement> annotations,
			RoundEnvironment roundEnv) {
		errorsFound = false;
		if (!roundEnv.processingOver()) {
			Set<? extends Element> elements = roundEnv.getRootElements();

			for (Element element : elements) {
				component = null;
				references = new Hashtable<String, org.jdom.Element>();

				List<? extends AnnotationMirror> annotationMirrors = element
						.getAnnotationMirrors();

				for (AnnotationMirror mirror : annotationMirrors) {
					final String annotationType = mirror.getAnnotationType()
							.toString();
					if (annotationType.equals(Component.class.getName())) {
						component = new org.jdom.Element("component");
						scanner.scan(element);
					}
				}

				if (component != null && !errorsFound) {
					Document doc = new Document();
					doc.addContent(new Comment(
							"Generated by A4DS - Do not edit"));
					doc.setRootElement(component);
					XMLOutputter fmt = new XMLOutputter();
					Format format = Format.getPrettyFormat();
					format.setIndent("    ");
					fmt.setFormat(format);

					OutputStream os = null;
					try {
						String fileName = component.getAttributeValue("name");
						if (fileName.indexOf('.') != -1) {
							fileName = fileName.substring(fileName
									.lastIndexOf('.') + 1);
						}
						fileName += ".xml";
						if (outputDir != null) {
							fileName = outputDir + "/" + fileName;
						}

						final FileObject fo = processingEnv.getFiler()
								.createResource(StandardLocation.SOURCE_OUTPUT,
										"", fileName);
						os = fo.openOutputStream();

						fmt.output(doc, os);
						processingEnv.getMessager().printMessage(
								Diagnostic.Kind.NOTE,
								"A4DS annotation processor: wrote file "
										+ fo.toUri());

					} catch (Throwable e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					} finally {
						try {
							os.close();
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			}
		}
		return false;
	}

	private class Scanner extends ElementScanner6<Void, Void> {
		@Override
		public Void visitType(TypeElement e, Void p) {
			org.jdom.Element implementation = new org.jdom.Element(
					"implementation");
			implementation.setAttribute("class", e.toString());
			component.getContent().add(implementation);
			component.setAttribute("name", e.toString());
			Component componentAnnotation = e.getAnnotation(Component.class);
			if (componentAnnotation != null) {
				List<String> interfaces2 = new ArrayList<String>();
				String provides = componentAnnotation.provides();
				List<? extends TypeMirror> interfaces = e.getInterfaces();
				if (provides.trim().length() == 0) {
					for (TypeMirror mirror : interfaces) {
						interfaces2.add(mirror.toString());
					}
				} else {
					StringTokenizer tokenizer = new StringTokenizer(provides
							.trim(), ",");
					while (tokenizer.hasMoreElements()) {
						boolean foundInterface = false;
						String interfaze = tokenizer.nextToken();
						for (TypeMirror mirror : interfaces) {
							if (interfaze.equals(mirror.toString())) {
								interfaces2.add(interfaze);
								foundInterface = true;
							}
						}
						if (!foundInterface) {
							processingEnv.getMessager().printMessage(
									Diagnostic.Kind.ERROR,
									"class does not implement declared interface \""
											+ interfaze + "\"", e);
							errorsFound = true;
						}
					}
				}
				if (interfaces2.size() > 0 && component != null) {
					org.jdom.Element service = new org.jdom.Element("service");
					component.getContent().add(service);
					for (String serviceInterface : interfaces2) {
						org.jdom.Element provide = new org.jdom.Element(
								"provide");
						provide.setAttribute("interface", serviceInterface);
						service.getContent().add(provide);
					}
				}

			}
			super.visitType(e, p);
			return null;
		}

		@Override
		public Void visitExecutable(ExecutableElement e, Void p) {
			if (e.getKind() == ElementKind.METHOD) {
				if (e.getAnnotation(Bind.class) != null
						|| e.getAnnotation(Unbind.class) != null) {

					String serviceInterface = e.getParameters().get(0).asType()
							.toString();
					org.jdom.Element reference = references
							.get(serviceInterface);
					if (reference == null) {
						reference = new org.jdom.Element("reference");
						references.put(serviceInterface, reference);
						reference.setAttribute("name", serviceInterface);
						component.getContent().add(reference);
					}
					reference.setAttribute("interface", serviceInterface);

					String bindAttribute;
					if (e.getAnnotation(Unbind.class) != null) {
						bindAttribute = "unbind";
					} else {
						bindAttribute = "bind";
						Bind bind = e.getAnnotation(Bind.class);
						reference.setAttribute("cardinality", bind
								.cardinality());
						reference.setAttribute("policy", bind.policy());
					}

					reference.setAttribute(bindAttribute, e.getSimpleName()
							.toString());
				}
			}
			return null;
		}
	}
}
